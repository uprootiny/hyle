<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dodeca — hyle</title>
    <meta name="description" content="Spiky dodecahedron with noise-perturbed vertices and rotoscoped rendering">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>λ</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #000;
            --text: #f0f0f3;
            --text-secondary: #a0a0ab;
            --text-muted: #606068;
            --accent: #10b981;
            --accent-bright: #34d399;
            --border: #1a1a20;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-sans);
            overflow: hidden;
        }

        canvas { display: block; }

        /* Nav */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text);
            text-decoration: none;
            font-weight: 600;
        }

        .brand .lambda { color: var(--accent); font-size: 1.25rem; }
        .brand:hover .lambda { color: var(--accent-bright); }

        .back-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.85rem;
            transition: color 0.2s;
        }

        .back-link:hover { color: var(--accent); }

        /* Controls Panel */
        .controls {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            backdrop-filter: blur(12px);
            z-index: 100;
            min-width: 220px;
        }

        .controls h3 {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent);
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }

        .control-label {
            color: var(--text-muted);
        }

        .control-value {
            font-family: var(--font-mono);
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
            accent-color: var(--accent);
            background: transparent;
        }

        .control-group {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .control-group:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .color-btn {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .color-btn:hover {
            border-color: var(--text-muted);
        }

        .color-btn.active {
            border-color: var(--accent);
        }

        .color-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            backdrop-filter: blur(12px);
            z-index: 100;
            max-width: 280px;
        }

        .info-panel h2 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .info-panel p {
            font-size: 0.85rem;
            color: var(--text-dim);
            line-height: 1.6;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-top: 0.75rem;
            font-size: 0.8rem;
        }

        .stat-label { color: var(--text-muted); }
        .stat-value { font-family: var(--font-mono); color: var(--accent); }

        /* Hint */
        .hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.85rem;
            color: var(--text-muted);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .hint.visible { opacity: 1; }
    </style>
</head>
<body>
    <nav>
        <a href="/" class="brand">
            <span class="lambda">λ</span>
            <span>hyle</span>
        </a>
        <a href="/projects/" class="back-link">← Projects</a>
    </nav>

    <div class="controls">
        <h3>Parameters</h3>
        <div class="control-group">
            <div class="control-row">
                <span class="control-label">Noise Amplitude</span>
                <span class="control-value" id="noiseVal">0.30</span>
            </div>
            <input type="range" id="noiseAmp" min="0" max="100" value="30">
        </div>
        <div class="control-group">
            <div class="control-row">
                <span class="control-label">Noise Frequency</span>
                <span class="control-value" id="freqVal">2.0</span>
            </div>
            <input type="range" id="noiseFreq" min="5" max="80" value="20">
        </div>
        <div class="control-group">
            <div class="control-row">
                <span class="control-label">Rotation Speed</span>
                <span class="control-value" id="speedVal">1.0</span>
            </div>
            <input type="range" id="rotSpeed" min="0" max="100" value="50">
        </div>
    </div>

    <div class="info-panel">
        <h2>Perturbed Icosahedron</h2>
        <p>Simplex noise displaces vertices along surface normals, creating organic deformation.</p>
        <div class="stat-row">
            <span class="stat-label">Vertices</span>
            <span class="stat-value" id="vertCount">2562</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Triangles</span>
            <span class="stat-value" id="triCount">1280</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Frame Rate</span>
            <span class="stat-value" id="fpsCount">60</span>
        </div>
    </div>

    <div class="hint" id="hint">drag to rotate</div>

    <canvas id="c"></canvas>
    <script type="module">
        // Minimal three.js-like WebGL renderer
        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Shaders
        const vertSrc = `#version 300 es
        in vec3 pos;
        in vec3 normal;
        uniform mat4 proj;
        uniform mat4 view;
        uniform mat4 model;
        uniform float time;
        out vec3 vNormal;
        out vec3 vPos;
        out float vNoise;

        // Simplex noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }

        void main() {
            // Perturb vertices with noise
            float n = snoise(pos * 2.0 + time * 0.3) * 0.3;
            float n2 = snoise(pos * 4.0 - time * 0.2) * 0.15;
            vec3 displaced = pos + normal * (n + n2);
            vNoise = n + n2;
            vNormal = mat3(model) * normal;
            vPos = (model * vec4(displaced, 1.0)).xyz;
            gl_Position = proj * view * model * vec4(displaced, 1.0);
        }`;

        const fragSrc = `#version 300 es
        precision highp float;
        in vec3 vNormal;
        in vec3 vPos;
        in float vNoise;
        uniform float time;
        out vec4 fragColor;

        void main() {
            vec3 norm = normalize(vNormal);
            vec3 light = normalize(vec3(1.0, 1.0, 1.0));

            // Edge detection via normal discontinuity
            float edge = 1.0 - abs(dot(norm, normalize(-vPos)));
            edge = smoothstep(0.3, 0.5, edge);

            // Base color from noise
            vec3 col1 = vec3(0.1, 0.2, 0.4);
            vec3 col2 = vec3(0.4, 0.1, 0.3);
            vec3 baseColor = mix(col1, col2, vNoise * 2.0 + 0.5);

            // Simple diffuse
            float diff = max(dot(norm, light), 0.0) * 0.5 + 0.5;
            vec3 color = baseColor * diff;

            // Add edge glow
            color += edge * vec3(0.4, 0.6, 1.0) * 0.5;

            // Stars in background
            if (gl_FragCoord.z > 0.999) {
                float stars = step(0.998, fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453));
                color = vec3(stars);
            }

            fragColor = vec4(color, 1.0);
        }`;

        function compileShader(src, type) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
            }
            return s;
        }

        const prog = gl.createProgram();
        gl.attachShader(prog, compileShader(vertSrc, gl.VERTEX_SHADER));
        gl.attachShader(prog, compileShader(fragSrc, gl.FRAGMENT_SHADER));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        // Generate icosahedron geometry
        const t = (1 + Math.sqrt(5)) / 2;
        const icoVerts = [
            [-1,t,0], [1,t,0], [-1,-t,0], [1,-t,0],
            [0,-1,t], [0,1,t], [0,-1,-t], [0,1,-t],
            [t,0,-1], [t,0,1], [-t,0,-1], [-t,0,1]
        ].map(v => { const l = Math.sqrt(v[0]**2+v[1]**2+v[2]**2); return v.map(x => x/l); });

        const icoFaces = [
            [0,11,5], [0,5,1], [0,1,7], [0,7,10], [0,10,11],
            [1,5,9], [5,11,4], [11,10,2], [10,7,6], [7,1,8],
            [3,9,4], [3,4,2], [3,2,6], [3,6,8], [3,8,9],
            [4,9,5], [2,4,11], [6,2,10], [8,6,7], [9,8,1]
        ];

        // Subdivide
        function subdivide(verts, faces, n) {
            for (let i = 0; i < n; i++) {
                const newFaces = [];
                const midCache = {};
                const getMid = (a, b) => {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (midCache[key] !== undefined) return midCache[key];
                    const mid = [
                        (verts[a][0] + verts[b][0]) / 2,
                        (verts[a][1] + verts[b][1]) / 2,
                        (verts[a][2] + verts[b][2]) / 2
                    ];
                    const l = Math.sqrt(mid[0]**2 + mid[1]**2 + mid[2]**2);
                    verts.push(mid.map(x => x/l));
                    midCache[key] = verts.length - 1;
                    return midCache[key];
                };
                for (const [a, b, c] of faces) {
                    const ab = getMid(a, b);
                    const bc = getMid(b, c);
                    const ca = getMid(c, a);
                    newFaces.push([a, ab, ca], [b, bc, ab], [c, ca, bc], [ab, bc, ca]);
                }
                faces = newFaces;
            }
            return { verts, faces };
        }

        const { verts, faces } = subdivide([...icoVerts], [...icoFaces], 3);

        // Build buffers
        const positions = [];
        const normals = [];
        for (const [a, b, c] of faces) {
            const va = verts[a], vb = verts[b], vc = verts[c];
            positions.push(...va, ...vb, ...vc);
            // Face normal
            const e1 = [vb[0]-va[0], vb[1]-va[1], vb[2]-va[2]];
            const e2 = [vc[0]-va[0], vc[1]-va[1], vc[2]-va[2]];
            const n = [
                e1[1]*e2[2] - e1[2]*e2[1],
                e1[2]*e2[0] - e1[0]*e2[2],
                e1[0]*e2[1] - e1[1]*e2[0]
            ];
            const nl = Math.sqrt(n[0]**2 + n[1]**2 + n[2]**2);
            const nn = n.map(x => x/nl);
            normals.push(...nn, ...nn, ...nn);
        }

        const posBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(prog, 'pos');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        const normBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        const normLoc = gl.getAttribLocation(prog, 'normal');
        gl.enableVertexAttribArray(normLoc);
        gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);

        // Uniforms
        const projLoc = gl.getUniformLocation(prog, 'proj');
        const viewLoc = gl.getUniformLocation(prog, 'view');
        const modelLoc = gl.getUniformLocation(prog, 'model');
        const timeLoc = gl.getUniformLocation(prog, 'time');

        function perspective(fov, aspect, near, far) {
            const f = 1 / Math.tan(fov / 2);
            return new Float32Array([
                f/aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far+near)/(near-far), -1,
                0, 0, 2*far*near/(near-far), 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = [eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]];
            const zl = Math.sqrt(z[0]**2+z[1]**2+z[2]**2);
            z[0]/=zl; z[1]/=zl; z[2]/=zl;
            const x = [up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]];
            const xl = Math.sqrt(x[0]**2+x[1]**2+x[2]**2);
            x[0]/=xl; x[1]/=xl; x[2]/=xl;
            const y = [z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]];
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -x[0]*eye[0]-x[1]*eye[1]-x[2]*eye[2],
                -y[0]*eye[0]-y[1]*eye[1]-y[2]*eye[2],
                -z[0]*eye[0]-z[1]*eye[1]-z[2]*eye[2], 1
            ]);
        }

        function rotateY(a) {
            const c = Math.cos(a), s = Math.sin(a);
            return new Float32Array([c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1]);
        }

        function rotateX(a) {
            const c = Math.cos(a), s = Math.sin(a);
            return new Float32Array([1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]);
        }

        function mulMat(a, b) {
            const r = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    r[i*4+j] = a[i*4]*b[j] + a[i*4+1]*b[4+j] + a[i*4+2]*b[8+j] + a[i*4+3]*b[12+j];
                }
            }
            return r;
        }

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0, 0, 0, 1);

        // Control state
        let rotSpeed = 1.0;
        let dragX = 0, dragY = 0;
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let autoRotateX = 0, autoRotateY = 0;

        // FPS tracking
        let frameCount = 0;
        let lastFpsTime = performance.now();

        // Wire up controls
        document.getElementById('noiseAmp').addEventListener('input', (e) => {
            const val = e.target.value / 100;
            document.getElementById('noiseVal').textContent = val.toFixed(2);
        });

        document.getElementById('noiseFreq').addEventListener('input', (e) => {
            const val = e.target.value / 10;
            document.getElementById('freqVal').textContent = val.toFixed(1);
        });

        document.getElementById('rotSpeed').addEventListener('input', (e) => {
            rotSpeed = e.target.value / 50;
            document.getElementById('speedVal').textContent = rotSpeed.toFixed(1);
        });

        // Mouse drag for rotation
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            document.getElementById('hint').classList.remove('visible');
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            dragX += (e.clientX - lastX) * 0.01;
            dragY += (e.clientY - lastY) * 0.01;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            dragX += (e.touches[0].clientX - lastX) * 0.01;
            dragY += (e.touches[0].clientY - lastY) * 0.01;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', () => isDragging = false);

        // Show hint initially
        setTimeout(() => document.getElementById('hint').classList.add('visible'), 1000);
        setTimeout(() => document.getElementById('hint').classList.remove('visible'), 4000);

        // Update stats display
        document.getElementById('vertCount').textContent = verts.length;
        document.getElementById('triCount').textContent = faces.length;

        function render(t) {
            const time = t * 0.001;
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const aspect = canvas.width / canvas.height;
            gl.uniformMatrix4fv(projLoc, false, perspective(Math.PI/4, aspect, 0.1, 100));
            gl.uniformMatrix4fv(viewLoc, false, lookAt([0, 0, 4], [0, 0, 0], [0, 1, 0]));

            // Auto-rotate when not dragging
            if (!isDragging) {
                autoRotateX += 0.003 * rotSpeed;
                autoRotateY += 0.002 * rotSpeed;
            }

            const model = mulMat(
                mulMat(rotateY(autoRotateX + dragX), rotateX(autoRotateY + dragY)),
                rotateY(time * 0.1 * rotSpeed)
            );
            gl.uniformMatrix4fv(modelLoc, false, model);
            gl.uniform1f(timeLoc, time);

            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 3);

            // Update FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fpsCount').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
