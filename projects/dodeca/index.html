<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dodeca - generative polyhedron</title>
    <meta name="hyle-sketch" content="spiky dodecahedron with perturbed surface using landscape generation algos. layered rotoscoped rendering floating over starry void">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            color: #666;
            font: 12px system-ui;
            pointer-events: none;
        }
        #info a { color: #6b9fff; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="info">
        <a href="https://uprootiny.github.io/hyle/">hyle</a> · dodeca · <a href="https://uprootiny.github.io/hyle/#sketch=spiky%20dodecahedron%20with%20perturbed%20surface%20using%20landscape%20generation%20algos.%20layered%20rotoscoped%20rendering%20floating%20over%20starry%20void">remix →</a>
    </div>
    <script type="module">
        // Minimal three.js-like WebGL renderer
        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Shaders
        const vertSrc = `#version 300 es
        in vec3 pos;
        in vec3 normal;
        uniform mat4 proj;
        uniform mat4 view;
        uniform mat4 model;
        uniform float time;
        out vec3 vNormal;
        out vec3 vPos;
        out float vNoise;

        // Simplex noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }

        void main() {
            // Perturb vertices with noise
            float n = snoise(pos * 2.0 + time * 0.3) * 0.3;
            float n2 = snoise(pos * 4.0 - time * 0.2) * 0.15;
            vec3 displaced = pos + normal * (n + n2);
            vNoise = n + n2;
            vNormal = mat3(model) * normal;
            vPos = (model * vec4(displaced, 1.0)).xyz;
            gl_Position = proj * view * model * vec4(displaced, 1.0);
        }`;

        const fragSrc = `#version 300 es
        precision highp float;
        in vec3 vNormal;
        in vec3 vPos;
        in float vNoise;
        uniform float time;
        out vec4 fragColor;

        void main() {
            vec3 norm = normalize(vNormal);
            vec3 light = normalize(vec3(1.0, 1.0, 1.0));

            // Edge detection via normal discontinuity
            float edge = 1.0 - abs(dot(norm, normalize(-vPos)));
            edge = smoothstep(0.3, 0.5, edge);

            // Base color from noise
            vec3 col1 = vec3(0.1, 0.2, 0.4);
            vec3 col2 = vec3(0.4, 0.1, 0.3);
            vec3 baseColor = mix(col1, col2, vNoise * 2.0 + 0.5);

            // Simple diffuse
            float diff = max(dot(norm, light), 0.0) * 0.5 + 0.5;
            vec3 color = baseColor * diff;

            // Add edge glow
            color += edge * vec3(0.4, 0.6, 1.0) * 0.5;

            // Stars in background
            if (gl_FragCoord.z > 0.999) {
                float stars = step(0.998, fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453));
                color = vec3(stars);
            }

            fragColor = vec4(color, 1.0);
        }`;

        function compileShader(src, type) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
            }
            return s;
        }

        const prog = gl.createProgram();
        gl.attachShader(prog, compileShader(vertSrc, gl.VERTEX_SHADER));
        gl.attachShader(prog, compileShader(fragSrc, gl.FRAGMENT_SHADER));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        // Generate icosahedron geometry
        const t = (1 + Math.sqrt(5)) / 2;
        const icoVerts = [
            [-1,t,0], [1,t,0], [-1,-t,0], [1,-t,0],
            [0,-1,t], [0,1,t], [0,-1,-t], [0,1,-t],
            [t,0,-1], [t,0,1], [-t,0,-1], [-t,0,1]
        ].map(v => { const l = Math.sqrt(v[0]**2+v[1]**2+v[2]**2); return v.map(x => x/l); });

        const icoFaces = [
            [0,11,5], [0,5,1], [0,1,7], [0,7,10], [0,10,11],
            [1,5,9], [5,11,4], [11,10,2], [10,7,6], [7,1,8],
            [3,9,4], [3,4,2], [3,2,6], [3,6,8], [3,8,9],
            [4,9,5], [2,4,11], [6,2,10], [8,6,7], [9,8,1]
        ];

        // Subdivide
        function subdivide(verts, faces, n) {
            for (let i = 0; i < n; i++) {
                const newFaces = [];
                const midCache = {};
                const getMid = (a, b) => {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (midCache[key] !== undefined) return midCache[key];
                    const mid = [
                        (verts[a][0] + verts[b][0]) / 2,
                        (verts[a][1] + verts[b][1]) / 2,
                        (verts[a][2] + verts[b][2]) / 2
                    ];
                    const l = Math.sqrt(mid[0]**2 + mid[1]**2 + mid[2]**2);
                    verts.push(mid.map(x => x/l));
                    midCache[key] = verts.length - 1;
                    return midCache[key];
                };
                for (const [a, b, c] of faces) {
                    const ab = getMid(a, b);
                    const bc = getMid(b, c);
                    const ca = getMid(c, a);
                    newFaces.push([a, ab, ca], [b, bc, ab], [c, ca, bc], [ab, bc, ca]);
                }
                faces = newFaces;
            }
            return { verts, faces };
        }

        const { verts, faces } = subdivide([...icoVerts], [...icoFaces], 3);

        // Build buffers
        const positions = [];
        const normals = [];
        for (const [a, b, c] of faces) {
            const va = verts[a], vb = verts[b], vc = verts[c];
            positions.push(...va, ...vb, ...vc);
            // Face normal
            const e1 = [vb[0]-va[0], vb[1]-va[1], vb[2]-va[2]];
            const e2 = [vc[0]-va[0], vc[1]-va[1], vc[2]-va[2]];
            const n = [
                e1[1]*e2[2] - e1[2]*e2[1],
                e1[2]*e2[0] - e1[0]*e2[2],
                e1[0]*e2[1] - e1[1]*e2[0]
            ];
            const nl = Math.sqrt(n[0]**2 + n[1]**2 + n[2]**2);
            const nn = n.map(x => x/nl);
            normals.push(...nn, ...nn, ...nn);
        }

        const posBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(prog, 'pos');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        const normBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        const normLoc = gl.getAttribLocation(prog, 'normal');
        gl.enableVertexAttribArray(normLoc);
        gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);

        // Uniforms
        const projLoc = gl.getUniformLocation(prog, 'proj');
        const viewLoc = gl.getUniformLocation(prog, 'view');
        const modelLoc = gl.getUniformLocation(prog, 'model');
        const timeLoc = gl.getUniformLocation(prog, 'time');

        function perspective(fov, aspect, near, far) {
            const f = 1 / Math.tan(fov / 2);
            return new Float32Array([
                f/aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far+near)/(near-far), -1,
                0, 0, 2*far*near/(near-far), 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = [eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]];
            const zl = Math.sqrt(z[0]**2+z[1]**2+z[2]**2);
            z[0]/=zl; z[1]/=zl; z[2]/=zl;
            const x = [up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]];
            const xl = Math.sqrt(x[0]**2+x[1]**2+x[2]**2);
            x[0]/=xl; x[1]/=xl; x[2]/=xl;
            const y = [z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]];
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -x[0]*eye[0]-x[1]*eye[1]-x[2]*eye[2],
                -y[0]*eye[0]-y[1]*eye[1]-y[2]*eye[2],
                -z[0]*eye[0]-z[1]*eye[1]-z[2]*eye[2], 1
            ]);
        }

        function rotateY(a) {
            const c = Math.cos(a), s = Math.sin(a);
            return new Float32Array([c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1]);
        }

        function rotateX(a) {
            const c = Math.cos(a), s = Math.sin(a);
            return new Float32Array([1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]);
        }

        function mulMat(a, b) {
            const r = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    r[i*4+j] = a[i*4]*b[j] + a[i*4+1]*b[4+j] + a[i*4+2]*b[8+j] + a[i*4+3]*b[12+j];
                }
            }
            return r;
        }

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0, 0, 0, 1);

        function render(t) {
            const time = t * 0.001;
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const aspect = canvas.width / canvas.height;
            gl.uniformMatrix4fv(projLoc, false, perspective(Math.PI/4, aspect, 0.1, 100));
            gl.uniformMatrix4fv(viewLoc, false, lookAt([0, 0, 4], [0, 0, 0], [0, 1, 0]));

            const model = mulMat(rotateY(time * 0.3), rotateX(time * 0.2));
            gl.uniformMatrix4fv(modelLoc, false, model);
            gl.uniform1f(timeLoc, time);

            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 3);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
