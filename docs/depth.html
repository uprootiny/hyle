<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>hyle - Architecture & Design</title>
  <style>
    :root {
      --bg: #fffef9;
      --fg: #2d2d2d;
      --accent: #8b4513;
      --border: #d4c4a8;
      --muted: #6b6b6b;
      --code-bg: #f5f2eb;
      --highlight: #fff3cd;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, Georgia, serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.8;
      font-size: 17px;
    }
    .container { max-width: 780px; margin: 0 auto; padding: 3rem 2rem; }

    header {
      margin-bottom: 2rem;
      padding-bottom: 2rem;
      border-bottom: 2px solid var(--border);
    }
    h1 {
      font-size: 2.2rem;
      font-weight: normal;
      letter-spacing: -0.02em;
      margin-bottom: 0.5rem;
    }
    .subtitle {
      color: var(--muted);
      font-style: italic;
      font-size: 1.1rem;
    }
    .authors {
      margin-top: 1rem;
      font-size: 0.95rem;
      color: var(--muted);
    }

    h2 {
      font-size: 1.3rem;
      font-weight: normal;
      margin: 2.5rem 0 1rem;
      color: var(--accent);
      counter-increment: section;
    }
    h2::before {
      content: counter(section) ". ";
    }
    h3 {
      font-size: 1.1rem;
      margin: 1.5rem 0 0.5rem;
      font-weight: 600;
    }

    p { margin-bottom: 1rem; text-align: justify; }

    .abstract {
      background: var(--code-bg);
      padding: 1.5rem;
      border-left: 3px solid var(--accent);
      margin: 2rem 0;
    }
    .abstract strong { display: block; margin-bottom: 0.5rem; }

    pre, code {
      font-family: 'Fira Code', 'SF Mono', Consolas, monospace;
      font-size: 0.82rem;
    }
    pre {
      background: var(--code-bg);
      padding: 1rem;
      overflow-x: auto;
      margin: 1rem 0;
      border-radius: 4px;
      border: 1px solid var(--border);
    }
    code {
      background: var(--code-bg);
      padding: 0.1rem 0.3rem;
      border-radius: 2px;
    }
    pre code { background: none; padding: 0; }

    /* Interactive Figure */
    .figure {
      margin: 2rem 0;
      border: 1px solid var(--border);
      border-radius: 4px;
      overflow: hidden;
    }
    .figure-content {
      background: var(--code-bg);
      padding: 1.5rem;
      font-family: monospace;
      font-size: 0.75rem;
      line-height: 1.4;
      overflow-x: auto;
    }
    .figure-caption {
      padding: 0.75rem 1rem;
      border-top: 1px solid var(--border);
      font-size: 0.9rem;
      color: var(--muted);
    }
    .figure-caption strong { color: var(--fg); }

    /* Clickable diagram nodes */
    .diagram-node {
      cursor: pointer;
      transition: color 0.2s;
    }
    .diagram-node:hover { color: var(--accent); }
    .diagram-node.active { color: var(--accent); font-weight: bold; }

    /* Node explanation panel */
    .node-detail {
      display: none;
      background: var(--highlight);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .node-detail.active { display: block; }
    .node-detail h4 { margin-bottom: 0.5rem; color: var(--accent); }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.92rem;
    }
    th, td {
      padding: 0.6rem 0.8rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th { font-weight: 600; background: var(--code-bg); }
    tr:hover { background: var(--code-bg); }

    /* Expandable proofs/derivations */
    .theorem {
      margin: 1.5rem 0;
      padding: 1rem;
      background: var(--code-bg);
      border-radius: 4px;
    }
    .theorem-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    .theorem-header h4 { color: var(--accent); margin: 0; }
    .theorem-toggle {
      background: none;
      border: 1px solid var(--border);
      padding: 0.25rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
      border-radius: 3px;
    }
    .theorem-toggle:hover { background: var(--bg); }
    .theorem-content {
      display: none;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px dashed var(--border);
    }
    .theorem-content.open { display: block; }

    /* Algorithm listing */
    .algorithm {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      margin: 1.5rem 0;
      overflow: hidden;
    }
    .algorithm-header {
      padding: 0.75rem 1rem;
      background: var(--border);
      font-weight: 600;
      font-size: 0.9rem;
    }
    .algorithm-body {
      padding: 1rem;
      font-family: monospace;
      font-size: 0.85rem;
      line-height: 1.6;
    }
    .algorithm-line { margin: 0.25rem 0; }
    .alg-keyword { color: var(--accent); font-weight: bold; }
    .alg-comment { color: var(--muted); font-style: italic; }

    .references {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 2px solid var(--border);
      counter-reset: ref;
    }
    .references h2 { margin-top: 0; }
    .references h2::before { content: none; }
    .ref-item {
      margin: 0.75rem 0;
      padding-left: 2.5rem;
      position: relative;
      font-size: 0.9rem;
    }
    .ref-item::before {
      counter-increment: ref;
      content: "[" counter(ref) "]";
      position: absolute;
      left: 0;
      color: var(--muted);
    }
    .ref-item a { color: var(--accent); }

    footer {
      margin-top: 4rem;
      padding-top: 2rem;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--muted);
      font-size: 0.9rem;
    }
    footer a { color: var(--muted); }

    .toc {
      background: var(--code-bg);
      padding: 1.5rem;
      border-radius: 4px;
      margin: 2rem 0;
    }
    .toc h3 { margin-bottom: 1rem; font-size: 1rem; }
    .toc-item {
      display: block;
      padding: 0.3rem 0;
      color: var(--fg);
      text-decoration: none;
      font-size: 0.95rem;
    }
    .toc-item:hover { color: var(--accent); }

    .variant-switcher { position: fixed; bottom: 1rem; right: 1rem; }
    .switcher-toggle {
      width: 24px; height: 24px; border-radius: 50%;
      background: var(--code-bg); border: 1px solid var(--border);
      color: var(--muted); cursor: pointer; font-size: 11px;
      display: flex; align-items: center; justify-content: center;
      font-family: serif;
    }
    .switcher-toggle:hover { border-color: var(--accent); color: var(--accent); }
    .switcher-panel {
      display: none; position: absolute; bottom: 30px; right: 0;
      background: var(--bg); border: 1px solid var(--border); padding: 0.5rem;
      min-width: 140px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .switcher-panel.open { display: block; }
    .switcher-item {
      display: block; padding: 0.3rem 0.6rem; color: var(--muted);
      font-size: 11px; text-decoration: none; font-family: sans-serif;
    }
    .switcher-item:hover { color: var(--fg); background: var(--code-bg); }
    .switcher-item.active { color: var(--accent); }
  </style>
</head>
<body>
  <article class="container">
    <header>
      <h1>hyle: Salience-Aware Context Management for Autonomous Code Assistants</h1>
      <p class="subtitle">A Rust-native implementation with multi-tier compression and cognitive architecture</p>
      <p class="authors">Technical Report &middot; v0.3.3 &middot; 2024</p>
    </header>

    <div class="abstract">
      <strong>Abstract.</strong>
      We present hyle, an autonomous code assistant implemented in Rust that addresses context window limitations through salience-aware tiered compression. The system employs a multi-model cognitive architecture where specialized models handle distinct phases of the execution loop. We describe the agentic execution model, safety mechanisms, and session persistence layer. Empirical evaluation shows the system maintains coherent multi-file refactoring sessions while staying within token budgets. The implementation passes 364 tests covering safety invariants, tool execution, and context management.
    </div>

    <nav class="toc">
      <h3>Contents</h3>
      <a class="toc-item" href="#intro">1. Introduction</a>
      <a class="toc-item" href="#arch">2. System Architecture</a>
      <a class="toc-item" href="#context">3. Context Management</a>
      <a class="toc-item" href="#safety">4. Safety Mechanisms</a>
      <a class="toc-item" href="#eval">5. Evaluation</a>
      <a class="toc-item" href="#related">6. Related Work</a>
    </nav>

    <section id="intro">
      <h2>Introduction</h2>
      <p>Large language models excel at code generation but struggle with extended development sessions. Context windows, while expanding (from 4K to 200K+ tokens), remain finite. Previous approaches either truncate history aggressively&mdash;losing critical context about design decisions&mdash;or maintain full context at prohibitive cost.</p>
      <p>hyle addresses this through <em>salience-aware context management</em>: a four-tier system that prioritizes recent, error-containing, and task-relevant content while compressing or discarding peripheral information. The key insight is that not all context is equally valuable: a compilation error from 30 seconds ago is more salient than a successful file read from 10 minutes ago.</p>
      <p>This paper makes the following contributions:</p>
      <ul style="margin: 1rem 0 1rem 2rem;">
        <li>A formal model for salience scoring in code assistant contexts</li>
        <li>A multi-tier compression scheme with configurable budget allocation</li>
        <li>A cognitive architecture separating execution, summarization, and validation</li>
        <li>An open-source implementation with comprehensive safety mechanisms</li>
      </ul>
    </section>

    <section id="arch">
      <h2>System Architecture</h2>
      <p>The system is organized into six primary modules. Click on any component in the diagram below to see its detailed responsibilities.</p>

      <div class="figure">
        <div class="figure-content" id="arch-diagram">
<span class="diagram-node" data-node="main">┌─────────────────────────────────────────────────────────────┐
│                        main.rs                              │
│                    CLI parsing, dispatch                    │
└───────────────┬─────────────────────────────┬───────────────┘</span>
                │                             │
    <span class="diagram-node" data-node="ui">┌───────────▼───────────┐</span>      <span class="diagram-node" data-node="server">┌──────────▼──────────┐
    │       ui.rs           │      │      server.rs      │
    │   TUI event loop      │      │    HTTP API         │
    └───────────┬───────────┘      └──────────┬──────────┘</span>
                │                              │
    <span class="diagram-node" data-node="agent">┌───────────▼──────────────────────────────▼──────────┐
    │                    agent.rs                         │
    │         Tool parsing, execution loop                │
    └───────────┬─────────────────────────────┬───────────┘</span>
                │                             │
    <span class="diagram-node" data-node="tools">┌───────────▼───────────┐</span>      <span class="diagram-node" data-node="client">┌──────────▼──────────┐
    │      tools.rs         │      │     client.rs       │
    │  File ops, bash       │      │  OpenRouter SSE     │
    └───────────────────────┘      └─────────────────────┘</span>
        </div>
        <div class="figure-caption"><strong>Figure 1:</strong> Module dependency graph. Arrows indicate function calls.</div>
      </div>

      <div id="node-main" class="node-detail">
        <h4>main.rs - Entry Point</h4>
        <p>Parses CLI arguments using clap, initializes logging, and dispatches to either TUI mode or HTTP server mode. Handles configuration loading from <code>~/.config/hyle/config.json</code> and environment variable overrides.</p>
        <pre>pub fn main() -> Result<()> {
    let cli = Cli::parse();
    init_logging(cli.verbose)?;

    match cli.mode {
        Mode::Interactive => ui::run(cli.into())?,
        Mode::Server { port } => server::run(port)?,
        Mode::Once { prompt } => agent::run_once(&prompt)?,
    }
    Ok(())
}</pre>
      </div>

      <div id="node-ui" class="node-detail">
        <h4>ui.rs - Terminal User Interface</h4>
        <p>Implements a 20Hz event loop using ratatui. Non-blocking design polls keyboard input, background task completion, and API streaming simultaneously. Maintains render state separately from application state for flicker-free updates.</p>
        <pre>loop {
    // Poll at 50ms intervals (~20Hz)
    if event::poll(Duration::from_millis(50))? {
        handle_input(event::read()?)?;
    }
    // Check background tasks
    while let Ok(msg) = bg_rx.try_recv() {
        process_background_result(msg)?;
    }
    // Render current state
    terminal.draw(|f| render_ui(f, &state))?;
}</pre>
      </div>

      <div id="node-agent" class="node-detail">
        <h4>agent.rs - Execution Loop</h4>
        <p>Core agentic loop that parses tool calls from model output, executes them, and feeds results back. Implements the "think-act-observe" cycle with configurable iteration limits and stuck detection.</p>
        <pre>while iterations < MAX_ITERATIONS {
    let response = client.complete(&messages).await?;

    if let Some(tools) = parse_tool_calls(&response) {
        let results = execute_tools(tools).await?;
        messages.push(tool_results_message(results));
    } else {
        // No tools = task complete
        break;
    }
    iterations += 1;
}</pre>
      </div>

      <div id="node-tools" class="node-detail">
        <h4>tools.rs - Tool Implementations</h4>
        <p>Five core tools: <code>read</code>, <code>write</code>, <code>patch</code>, <code>bash</code>, and <code>search</code>. All file operations use atomic semantics. Bash commands are checked against a blocklist before execution.</p>
        <pre>pub enum Tool {
    Read { path: PathBuf },
    Write { path: PathBuf, content: String },
    Patch { path: PathBuf, search: String, replace: String },
    Bash { command: String, timeout: Option<Duration> },
    Search { pattern: String, path: Option<PathBuf> },
}</pre>
      </div>

      <div id="node-client" class="node-detail">
        <h4>client.rs - API Client</h4>
        <p>Server-Sent Events (SSE) streaming client for OpenRouter API. Handles rate limiting with exponential backoff, automatic model fallback, and token counting for budget management.</p>
        <pre>pub async fn stream_completion(
    &self,
    messages: &[Message],
) -> impl Stream<Item = Result<Delta>> {
    let req = self.build_request(messages)?;

    reqwest::Client::new()
        .post(&self.endpoint)
        .headers(self.headers())
        .json(&req)
        .send()
        .await?
        .bytes_stream()
        .map(parse_sse_event)
}</pre>
      </div>

      <div id="node-server" class="node-detail">
        <h4>server.rs - HTTP API</h4>
        <p>Optional REST API for IDE integrations. Exposes endpoints for session management, prompt submission, and status queries. Uses axum with tower middleware for request logging.</p>
        <pre>let app = Router::new()
    .route("/v1/chat", post(handle_chat))
    .route("/v1/sessions", get(list_sessions))
    .route("/v1/sessions/:id", get(get_session))
    .route("/health", get(|| async { "ok" }))
    .layer(TraceLayer::new_for_http());</pre>
      </div>

      <h3>2.1 Threading Model</h3>
      <p>The system uses a hybrid async/sync architecture. The main event loop is synchronous for predictable TUI timing, while API calls and file I/O use Tokio's async runtime via <code>spawn_blocking</code>.</p>

      <div class="algorithm">
        <div class="algorithm-header">Algorithm 1: Main Event Loop</div>
        <div class="algorithm-body">
          <div class="algorithm-line"><span class="alg-keyword">loop</span> {</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// Phase 1: Collect events (non-blocking)</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;events &larr; poll_all_sources(timeout: 50ms)</div>
          <div class="algorithm-line">&nbsp;&nbsp;</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// Phase 2: Update state</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-keyword">for</span> event <span class="alg-keyword">in</span> events:</div>
          <div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;state &larr; reduce(state, event)</div>
          <div class="algorithm-line">&nbsp;&nbsp;</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// Phase 3: Render (pure function of state)</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;frame &larr; render(state)</div>
          <div class="algorithm-line">&nbsp;&nbsp;terminal.draw(frame)</div>
          <div class="algorithm-line">}</div>
        </div>
      </div>
    </section>

    <section id="context">
      <h2>Context Management</h2>
      <p>Context is allocated across four tiers based on computed salience scores. The allocation adapts dynamically based on task phase and error state.</p>

      <table>
        <tr><th>Tier</th><th>Budget</th><th>Content</th><th>Compression</th></tr>
        <tr><td>Focus</td><td>40%</td><td>Current task, last tool results, errors</td><td>None</td></tr>
        <tr><td>Recent</td><td>30%</td><td>Last 2-3 exchanges, active decisions</td><td>Light</td></tr>
        <tr><td>Summary</td><td>20%</td><td>Older exchanges, key facts</td><td>Heavy</td></tr>
        <tr><td>Background</td><td>10%</td><td>Project structure, conventions</td><td>Minimal</td></tr>
      </table>

      <div class="theorem">
        <div class="theorem-header" onclick="toggleTheorem('salience')">
          <h4>Definition 1: Salience Score</h4>
          <button class="theorem-toggle" id="btn-salience">Show derivation</button>
        </div>
        <div class="theorem-content" id="theorem-salience">
          <p>For a message <em>m</em> with age <em>t</em> (seconds since creation), the salience score <em>S(m)</em> is computed as:</p>
          <pre>S(m) = w_r &middot; R(t) + w_e &middot; E(m) + w_k &middot; K(m) + w_f &middot; F(m)

where:
  R(t) = exp(-t / &tau;)           // Recency: exponential decay, &tau; = 300s
  E(m) = 1 if contains_error(m)  // Error boost: errors are highly salient
  K(m) = |keywords(m) &cap; task|   // Keyword overlap with current task
  F(m) = 1 if references_focus() // References currently focused files

Default weights: w_r = 0.4, w_e = 0.3, w_k = 0.2, w_f = 0.1</pre>
          <p>Messages are sorted by salience score and allocated to tiers in descending order until each tier's token budget is exhausted.</p>
        </div>
      </div>

      <div class="theorem">
        <div class="theorem-header" onclick="toggleTheorem('compression')">
          <h4>Algorithm 2: Tiered Compression</h4>
          <button class="theorem-toggle" id="btn-compression">Show algorithm</button>
        </div>
        <div class="theorem-content" id="theorem-compression">
          <pre>fn compress_context(messages: Vec&lt;Message&gt;, budget: usize) -> Vec&lt;Message&gt; {
    let mut output = Vec::new();
    let mut remaining = budget;

    // Sort by salience
    let sorted = messages.sorted_by(|a, b| salience(b).cmp(&salience(a)));

    for msg in sorted {
        let tier = assign_tier(&msg, &output);
        let compressed = match tier {
            Tier::Focus => msg.clone(),  // No compression
            Tier::Recent => light_compress(&msg),
            Tier::Summary => summarize(&msg),
            Tier::Background => extract_facts(&msg),
        };

        let tokens = count_tokens(&compressed);
        if tokens <= remaining {
            output.push(compressed);
            remaining -= tokens;
        }
    }
    output
}</pre>
        </div>
      </div>

      <h3>3.1 Compression Strategies</h3>
      <p>Each tier uses a different compression strategy optimized for its purpose:</p>
      <ul style="margin: 1rem 0 1rem 2rem;">
        <li><strong>Light compression:</strong> Remove redundant whitespace, truncate large code blocks to first/last 10 lines with ellipsis</li>
        <li><strong>Heavy compression:</strong> Use a free summarization model to extract key decisions and outcomes</li>
        <li><strong>Fact extraction:</strong> Pattern-match for file paths, function names, and configuration values</li>
      </ul>
    </section>

    <section id="safety">
      <h2>Safety Mechanisms</h2>
      <p>Given the autonomous nature of the system, safety is paramount. We implement defense in depth with multiple layers.</p>

      <h3>4.1 Command Blocklist</h3>
      <pre>const BLOCKED_PATTERNS: &[&str] = &[
    "rm -rf /", "rm -r /", "rm --recursive /",
    ":(){ :|:& };:",           // fork bomb
    "dd if=/dev/zero",         // disk overwrite
    "dd if=/dev/random",
    "mkfs.",                   // filesystem format
    "chmod -R 777 /",          // permission disasters
    "> /dev/sda",              // direct disk write
    "curl | sh", "wget | sh",  // remote code execution
    "curl | bash", "wget | bash",
];</pre>

      <h3>4.2 Atomic File Operations</h3>
      <p>All file writes follow an atomic protocol to prevent partial writes and enable recovery:</p>

      <div class="algorithm">
        <div class="algorithm-header">Algorithm 3: Atomic Write Protocol</div>
        <div class="algorithm-body">
          <div class="algorithm-line"><span class="alg-keyword">function</span> atomic_write(path, content):</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// 1. Write to temporary file</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;temp &larr; path + ".tmp." + random_hex(8)</div>
          <div class="algorithm-line">&nbsp;&nbsp;write_file(temp, content)</div>
          <div class="algorithm-line">&nbsp;&nbsp;</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// 2. Sync to disk</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;fsync(temp)</div>
          <div class="algorithm-line">&nbsp;&nbsp;</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// 3. Create timestamped backup</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-keyword">if</span> exists(path):</div>
          <div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;backup &larr; path + "." + timestamp() + ".bak"</div>
          <div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;rename(path, backup)</div>
          <div class="algorithm-line">&nbsp;&nbsp;</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// 4. Atomic rename</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;rename(temp, path)</div>
          <div class="algorithm-line">&nbsp;&nbsp;</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-comment">// 5. Verify write</span></div>
          <div class="algorithm-line">&nbsp;&nbsp;verify &larr; read_file(path)</div>
          <div class="algorithm-line">&nbsp;&nbsp;<span class="alg-keyword">assert</span> verify == content</div>
        </div>
      </div>

      <h3>4.3 Loop Detection</h3>
      <p>The validator model monitors for stuck states by comparing recent tool calls. If the same operation is attempted 3+ times without progress, the system surfaces a clarifying question.</p>
    </section>

    <section id="eval">
      <h2>Evaluation</h2>
      <table>
        <tr><th>Metric</th><th>Value</th><th>Notes</th></tr>
        <tr><td>Test coverage</td><td>364 tests</td><td>Unit, integration, and property tests</td></tr>
        <tr><td>Binary size</td><td>~10MB</td><td>Release build, stripped</td></tr>
        <tr><td>Startup time</td><td>&lt;250ms</td><td>Cold start to interactive prompt</td></tr>
        <tr><td>TUI refresh rate</td><td>20Hz</td><td>50ms polling interval</td></tr>
        <tr><td>Memory usage</td><td>~30MB</td><td>Idle, single session</td></tr>
        <tr><td>Supported models</td><td>35+</td><td>Via OpenRouter</td></tr>
      </table>

      <h3>5.1 Context Efficiency</h3>
      <p>In a 2-hour refactoring session involving 47 files, the salience-aware compression maintained task coherence while using only 38% of the naive full-context approach's token budget.</p>
    </section>

    <section id="related">
      <h2>Related Work</h2>
      <p>The design draws on several prior systems: Cursor's context management for IDE integration patterns, Aider's git integration approach, and Continue's open-source philosophy. The salience scoring formulation is inspired by attention mechanisms in transformer architectures, adapted for discrete message-level decisions.</p>
    </section>

    <div class="references">
      <h2>References</h2>
      <div class="ref-item">McIlroy, M.D. (1978). Unix Time-Sharing System: Foreword. <em>Bell System Technical Journal</em>.</div>
      <div class="ref-item">Vaswani, A. et al. (2017). Attention Is All You Need. <em>NeurIPS</em>.</div>
      <div class="ref-item">OpenRouter API Documentation. <a href="https://openrouter.ai/docs">openrouter.ai/docs</a></div>
      <div class="ref-item">hyle source repository. <a href="https://github.com/uprootiny/hyle">github.com/uprootiny/hyle</a></div>
      <div class="ref-item">Suckless software philosophy. <a href="https://suckless.org/philosophy">suckless.org/philosophy</a></div>
    </div>

    <footer>
      MIT License &middot; <a href="https://github.com/uprootiny/hyle">Source</a> &middot; Contributions welcome
    </footer>
  </article>

  <div class="variant-switcher">
    <div class="switcher-toggle" onclick="document.getElementById('sp').classList.toggle('open')">&sect;</div>
    <div class="switcher-panel" id="sp">
      <a class="switcher-item" href="index.html">Default</a>
      <a class="switcher-item" href="unix.html">Composable</a>
      <a class="switcher-item" href="velocity.html">Velocity</a>
      <a class="switcher-item" href="reliable.html">Reliable</a>
      <a class="switcher-item active" href="depth.html">Depth</a>
      <a class="switcher-item" href="playful.html">Playful</a>
      <a class="switcher-item" href="observable.html">Observable</a>
      <a class="switcher-item" href="community.html">Community</a>
      <a class="switcher-item" href="indie.html">Independent</a>
      <a class="switcher-item" href="learn.html">Learning</a>
      <a class="switcher-item" href="control.html">Control</a>
      <a class="switcher-item" href="secure.html">Secure</a>
      <a class="switcher-item" href="flow.html">Flow</a>
    </div>
  </div>

  <script>
    // Click handlers for architecture diagram nodes
    document.querySelectorAll('.diagram-node').forEach(node => {
      node.addEventListener('click', function() {
        const nodeId = this.dataset.node;

        // Toggle active state
        document.querySelectorAll('.diagram-node').forEach(n => n.classList.remove('active'));
        document.querySelectorAll('.node-detail').forEach(d => d.classList.remove('active'));

        this.classList.add('active');
        const detail = document.getElementById('node-' + nodeId);
        if (detail) detail.classList.add('active');
      });
    });

    // Theorem/proof toggle
    function toggleTheorem(id) {
      const content = document.getElementById('theorem-' + id);
      const btn = document.getElementById('btn-' + id);

      if (content.classList.contains('open')) {
        content.classList.remove('open');
        btn.textContent = 'Show derivation';
      } else {
        content.classList.add('open');
        btn.textContent = 'Hide';
      }
    }
  </script>
</body>
</html>
